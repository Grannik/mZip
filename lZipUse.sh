#!/bin/bash
echo -e "
\e[1;36m Use\e[0m\e[36m Применение\e[0m

 Программа полезна для упаковки набора файлов для распространения; для архивации
 файлов; и для экономии места на диске путем временного сжатия неиспользуемых
 файлов или каталогов.
 Программа zip помещает один или несколько сжатых файлов в один zip-архив вместе
 с информацией о файлах (имя, путь, дата, время последней модификации, защита и
 контрольная информация для проверки целостности файла). Вся структура каталогов
 может быть упакована в zip-архив с помощью одной команды. Коэффициенты сжатия от
 2:1 до 3:1 являются общими для текстовых файлов. zip имеет один метод сжатия
 (дефляция), а также может хранить файлы без сжатия. (Если добавлена поддержка
 bzip2, zip также может сжимать с использованием сжатия bzip2, но такие записи
 требуют достаточно современной распаковки для распаковки. Когда выбрано сжатие
 bzip2, оно заменяет дефляцию в качестве метода по умолчанию.) zip автоматически
 выбирает лучший из двух ( deflation или store или, если выбран bzip2, bzip2 или
 store) для каждого сжимаемого файла.
 Формат команды. Основной формат команды
 zip параметры архива inpath inpath ...
 где archive — это новый или существующий zip-архив, а inpath — это путь к ката-
 логу или файлу, который может включать подстановочные знаки. Получив имя сущест-
 вующего zip-архива, zip заменит записи с идентичными именами в zip-архиве (соот-
 ветствующие относительным именам, хранящимся в архиве) или добавит записи для
 новых имен. Например, если foo.zip существует и содержит файлы foo/file1 и
 foo/file2, а каталог foo содержит файлы foo/file1 и foo/file3, то:
\e[32m zip -r foo.zip foo\e[0m
 или более кратко:
\e[32m zip -r foo foo\e[0m
 заменит foo/file1 в foo.zip и добавит foo/file3 в foo.zip. После этого foo.zip
 содержит файлы foo/file1, foo/file2 и foo/file3, при этом foo/file2 не изменился.
 Итак, если перед выполнением команды zip foo.zip имеет:
\e[32m foo/file1 foo/file2\e[0m
 и каталог foo имеет:
\e[32m file1 file3\e[0m
 тогда foo.zip будет иметь:
\e[32m foo/file1 foo/file2 foo/file3\e[0m
 где foo/file1 заменяется, а foo/file3 является новым.
 -@ списки файлов.
 Если список файлов указан как -@ [Не в MacOS], zip берет список входных файлов
 из стандартного ввода, а не из командной строки. Например,
\e[32m zip -@ foo\e[0m
 будет хранить файлы, перечисленные по одному в строке на стандартном вводе в
 foo.zip. В Unix эта опция может быть использована с большим успехом в сочетании
 с командой find (1). Например, чтобы заархивировать все исходные файлы C
 в текущем каталоге и его подкаталогах:
\e[32m find . -name \"*.[ch]\" -print | zip source -@\e[0m
 (обратите внимание, что шаблон должен быть заключен в кавычки, чтобы оболочка не
 расширяла его). Потоковые вход и выход. zip также примет одно тире (\"-\")
 в качестве имени zip-файла, и в этом случае он запишет zip-файл в стандартный
 вывод, что позволит передать вывод в другую программу. Например:
\e[32m zip -r - . | dd of=/dev/nrst0 obs=16k\e[0m
 будет записывать выходные данные zip непосредственно на ленту с указанным размером
 блока для резервного копирования текущего каталога. zip также принимает одно тире
 (\"-\") в качестве имени сжимаемого файла, и в этом случае он будет считывать файл
 из стандартного ввода, позволяя zip принимать ввод из другой программы. Например:
\e[32m tar cf - . | zip backup -\e[0m
 будет сжимать вывод команды tar для резервного копирования текущего каталога.
 Как правило, это обеспечивает лучшее сжатие, чем в предыдущем примере с использо-
ванием параметра -r, потому что zip может использовать избыточность между файлами.
 Резервную копию можно восстановить с помощью команды
\e[32m unzip -p backup | tar xf -\e[0m
 Если имя zip-файла не задано и stdout не является терминалом, zip действует как
 фильтр, сжимая стандартный ввод в стандартный вывод. Например,
\e[32m tar cf - . | zip | dd of=/dev/nrst0 obs=16k\e[0m
 эквивалентно
\e[32m tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k\e[0m
 zip-архивы, созданные таким образом, могут быть извлечены с помощью программы
 funzip, входящей в пакет unzip, или gunzip, входящего в пакет gzip (но некоторые
 gunzip могут не поддерживать это, если zip использует расширения Zip64).
 Например:
\e[32m dd if=/dev/nrst0  ibs=16k | funzip | tar xvf -\e[0m
 Поток также можно сохранить в файл и разархивировать. Если включена поддержка
 Zip64 для больших файлов и архивов и zip используется в качестве фильтра,
 zip создает Zip64-архив, для чтения которого требуется распаковка, совместимая с
 PKZIP 4.5 или более поздней версии. Это делается для того, чтобы избежать
 неоднозначности в структуре zip-файла, как определено в текущем стандарте zip
 (PKWARE AppNote), где решение об использовании Zip64 должно быть принято до того,
 как данные будут записаны для записи, но для потока размер данных не известно на
 тот момент. Если известно, что объем данных меньше 4 ГБ, можно использовать пара-
 метр -fz- для предотвращения использования Zip64, но zip завершится с ошибкой,
 если Zip64 действительно необходим. zip 3 и unzip 6 и более поздние версии могут
 читать архивы с записями Zip64. Кроме того, zip удаляет расширения Zip64,
 если они не нужны, при копировании записей архива (см. параметр -U (--copy)).
 При направлении вывода в другой файл обратите внимание, что все параметры
 должны быть указаны до перенаправления, включая -x. Например:
\e[32m zip archive \"*.h\" \"*.c\" -x donotinclude.h orthis.h > tofile\e[0m

 ZIP-файлы. При изменении существующего zip-архива zip запишет временный файл с
 новым содержимым и заменит старый только тогда, когда процесс создания новой
 версии завершится без ошибок.
 Если имя zip-архива не содержит расширения, добавляется расширение .zip.
 Если имя уже содержит расширение, отличное от .zip, существующее расширение
 остается неизменным. Однако разделенные архивы (архивы, разделенные на несколь-
 ко файлов) требуют расширения .zip для последнего разделения.
 Сканирование и чтение файлов. Когда zip запускается, он сканирует файлы для
 обработки (при необходимости). Если это сканирование занимает более 5 секунд,
 zip отобразит сообщение «Сканирование файлов» и начнет отображать точки прогрес-
 са каждые 2 секунды или каждые несколько обработанных записей, в зависимости от
 того, что занимает больше времени. Если между точками есть более 2 секунд, это
 может указывать на то, что поиск каждого файла занимает время и может означать,
 например, медленное сетевое соединение. (На самом деле начальное сканирование
 файла представляет собой двухэтапный процесс, в котором за сканированием катало-
 га следует сортировка, и эти два этапа разделены пробелом в точках. При обновле-
 нии существующего архива пробел также появляется между сканированием существую-
 щего файла и сканирование нового файла.) Точки сканирования файлов не контроли-
 руются опцией -ds размер точки, но точки отключаются опцией -q тихая.
 Параметр -sf show files можно использовать для сканирования файлов и получения
 списка отсканированных файлов без фактической их обработки.
 Если zip не может прочитать файл, он выдает предупреждение, но продолжает.
 См. параметр -MM ниже, чтобы узнать больше о том, как zip обрабатывает шаблоны,
 которые не совпадают, и файлы, которые не читаются. Если некоторые файлы были
 пропущены, в конце операции zip выдается предупреждение, в котором указывается,
 сколько файлов было прочитано и сколько пропущено.
 Командные режимы. zip теперь поддерживает два различных типа командных режимов:
 внешний и внутренний. Внешние режимы (добавление, обновление и обновление)
 считывают файлы из файловой системы (а также из существующего архива), в то
 время как внутренние режимы (удаление и копирование) работают исключительно с
 записями в существующем архиве.
\e[32m add\e[0m Обновите существующие записи и добавьте новые файлы.
 Если архив не существует, создайте его. Это режим 'по умолчанию'.
\e[32m update (-u)\e[0m Обновите существующие записи,
 если они новее в файловой системе, и добавьте новые файлы.
 Если архив не существует, выдайте предупреждение, создайте новый архив.
\e[32m freshen (-f)\e[0m Обновите существующие записи архива,
 если они новее в файловой системе. Не добавляет новые файлы в архив.
\e[32m delete (-d)\e[0m Выберите записи в существующем архиве и удалите их.
\e[32m copy (-U)\e[0m Выберите записи в существующем архиве и скопируйте их в новый архив.
 Этот новый режим аналогичен обновлению, но шаблоны командной строки выбирают
 записи в существующем архиве, а не файлы из файловой системы, и он использует
 параметр --out для записи полученного архива в новый файл, а не для обновления
 существующего архива, оставляя исходный архив без изменений.

 Новый параметр синхронизации файлов (-FS) также считается новым режимом, хотя он
 аналогичен обновлению. Этот режим синхронизирует архив с файлами в ОС, только
 заменяя файлы в архиве, если время файла или размер файла ОС отличаются, добавляя
 новые файлы и удаляя записи из архива, где нет соответствующего файла.
 Поскольку в этом режиме записи из архива могут быть удалены,
 рассмотрите возможность создания резервной копии архива.
 Также см. -DF для создания архивов различий.
 См. описание каждой опции ниже для получения подробной информации
 и раздел ПРИМЕРЫ ниже для примеров.
 Разделить архивы. zip версии 3.0 и выше может создавать разделенные архивы.
 Разделенный архив — это стандартный zip-архив, разделенный на несколько файлов.
 (Обратите внимание, что разделенные архивы — это не просто архивы, разделенные на
 части, так как смещения записей теперь основаны на начале каждого разделения.
 Объединение частей вместе сделает эти смещения недействительными, но unzip обычно
 может справиться с этим. zip обычно отказывается для обработки такого
 объединенного архива, если для исправления смещений не используется опция
 исправления -FF.)

 Одно из применений разделенных архивов — хранение большого архива на нескольких
 съемных носителях. Для разделенного архива с 20 разделенными файлами файлы обычно
 называются (замените ARCHIVE на имя вашего архива) ARCHIVE.z01, ARCHIVE.z02, ...,
 ARCHIVE.z19, ARCHIVE.zip. Обратите внимание, что последний файл — это файл .zip
 Напротив, составные архивы представляют собой исходный многодисковый архив,
 обычно требующий гибких дисков и использующий метки томов для хранения номеров
 дисков. zip поддерживает разделенные архивы, но не составные архивы, хотя
 существует процедура преобразования разделенных архивов нужного размера в
 составные архивы. Обратное также верно, когда каждый файл составного архива может
 быть скопирован, чтобы файлы с указанными выше именами создавали разделенный архив

 Используйте -s, чтобы установить размер разделения и создать разделенный архив.
 Размер указывается в виде числа, за которым может следовать:
 k (кБ), m (МБ), g (ГБ) или t (ТБ) (по умолчанию — m).
 Опцию -sp можно использовать для приостановки архивации zip между разбиениями,
 чтобы, например, можно было заменить съемный носитель,
 но прочтите описания и предупреждения для -s и -sp ниже.

 Хотя zip не обновляет разделенные архивы, zip предоставляет новую опцию
 -O (--output-file или --out),
 позволяющую обновлять разделенные архивы и сохранять их в новом архиве. Например:
\e[32m zip inarchive.zip foo.c bar.c --out outarchive.zip\e[0m
 читает архив inarchive.zip, даже если он разделен, добавляет файлы foo.c и bar.c
 и записывает полученный архив в outarchive.zip. Если inarchive.zip разделен,
 то outarchive.zip по умолчанию имеет тот же размер разделения.
 Имейте в виду, что если outarchive.zip и любые разделенные файлы, созданные с его
 помощью, уже существуют, они всегда перезаписываются по мере необходимости без
 предупреждения. Это может быть изменено в будущем.

 Юникод. Хотя стандарт zip требует хранения путей в архиве с использованием
 определенного набора символов, на практике zip хранит пути в архивах в любом
 локальном наборе символов. Это создает проблемы, когда архив создается или
 обновляется в системе с использованием одного набора символов, а затем извлекается
 в другой системе с использованием другого набора символов.
 При компиляции с включенной поддержкой Unicode на платформах, поддерживающих
 широкие символы, zip теперь сохраняет в дополнение к стандартному локальному пути
 для обратной совместимости перевод пути UTF-8. Это обеспечивает общий
 универсальный набор символов для хранения путей, который позволяет полностью
 извлекать эти пути в других системах, поддерживающих Unicode, и максимально точно
 сопоставлять их в системах, которые этого не делают.
 В системах Win32, где пути внутренне хранятся в формате Unicode, но представлены
 в локальном наборе символов, возможно, что некоторые пути будут пропущены во время
 сканирования каталога локального набора символов. zip с поддержкой Unicode теперь
 может читать и сохранять эти пути. Обратите внимание, что системы Win 9x и
 файловые системы FAT не полностью поддерживают Unicode.
 Имейте в виду, что окна консоли в Win32 и Unix, например, иногда не точно
 отображают все символы из-за того, как каждая операционная система переключает
 наборы символов для отображения. Однако инструменты навигации по каталогам должны
 показывать правильные пути, если загружены необходимые шрифты.

 Формат командной строки. В этой версии zip обновлена обработка командной строки
 и добавлена поддержка длинных параметров. Короткие варианты принимают форму:
\e[32m -s[-][s[-]...][value][=value][ value]\e[0m

 где s — короткий вариант из одного или двух символов. Короткая опция, которая
 принимает значение, является последней в аргументе, а все, что следует за ней,
 принимается за значение. Если вариант можно отрицать и \"-\"сразу следует за опцией,
 опция отрицается. Короткие опции также могут быть заданы как отдельные аргументы.
\e[32m -s[-][value][=value][ value] -s[-][value][=value][ value] ...\e[0m
 Короткие параметры обычно принимают значения либо как часть того же аргумента,
 либо как следующий аргумент. Необязательный u003d также поддерживается. Так
\e[32m -ttmmddyyyy\e[0m
 and
\e[32m -tt=mmddyyyy\e[0m
 and
\e[32m -tt mmddyyyy\e[0m
 все работает. Опции -x и -i принимают списки значений и используют немного другой
 формат, описанный ниже. См. параметры -x и -i. Длинные опционы принимают форму
\e[32m --longoption[-][=value][ value]\e[0m
 где опция начинается с --, имеет многосимвольное имя, может включать тире в конце,
 чтобы отменить опцию (если опция поддерживает это), и может иметь значение
 (аргумент опции), указанное перед ним знаком u003d (без пробелов).
 Значения также могут следовать за аргументом. Так:
\e[32m --before-date=mmddyyyy\e[0m
 and
\e[32m --before-date mmddyyyy\e[0m
 оба работают.
 Длинные названия опций могут быть сокращены до кратчайших уникальных аббревиатур.
 См. описания опций ниже, для которых поддерживаются длинные опции.
 Чтобы избежать путаницы, не сокращайте отрицательную опцию встроенным тире (\"-\")
 перед тире, если вы планируете ее отрицать (анализатор рассмотрит завершающий тире
 например, для опции --some-option с использованием --some - как вариант,
 как часть имени, а не отрицательный тире).
 Это можно изменить, чтобы последний тире в --some- в будущем стал отрицательным.
"
