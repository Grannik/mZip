#!/bin/bash
source "sZip.sh"
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=38; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
TPUT  1 1;$E "$nb";UNMARK;
TPUT  2 2;$E "\e[36m Options\e[0m                                                      \e[2m Параметры, Опции\e[0m";
TPUT  3 1;$E "$nc";
TPUT 37 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 39 1;$E "$ne";UNMARK;}
#
  M0(){ TPUT  4 3; $e "Системы, использующие EBCDIC Преобразование файла в формат ASCII \e[32m -a --ascii \e[0m";}
  M1(){ TPUT  5 3; $e "Настроить самораспаковывающийся исполняемый архив           \e[32m -A --adjust-sfx \e[0m";}
  M2(){ TPUT  6 3; $e "Oчистите биты архива обрабатываемых файлов              \e[32m -AC --archive-clear \e[0m";}
  M3(){ TPUT  7 3; $e "[WIN32] Включать только файлы с установленным битом архива\e[32m -AS --archive-set \e[0m";}
  M4(){ TPUT  8 3; $e "[VM/CMS и MVS] принудительно считывают файл в двоичном виде     \e[32m -B --binary \e[0m";}
  M5(){ TPUT  9 3; $e "[TANDEM] задайте параметры форматирования Edit/Enscribe с n             \e[32m -Bn \e[0m";}
  M6(){ TPUT 10 3; $e "Используйте указанный путь временного zip-архива   \e[32m -b path --temp-path path \e[0m";}
  M7(){ TPUT 11 3; $e "Добавьте однострочные комментарии для каждого файла     \e[32m -c --entry-comments \e[0m";}
  M8(){ TPUT 12 3; $e "[VMS] Сохранить все дела на VMS                          \e[32m -C --preserve-case \e[0m";}
  M9(){ TPUT 13 3; $e "[VMS] Сохранить случай ODS2 на VMS                    \e[32m -C2 --preserve-case-2 \e[0m";}
 M10(){ TPUT 14 3; $e "Сохранить случай ODS5 на VMS                          \e[32m -C5 --preserve-case-5 \e[0m";}
 M11(){ TPUT 15 3; $e "Удалить (delete) записи из zip-архива                           \e[32m -d --delete \e[0m";}
 M12(){ TPUT 16 3; $e "Отображение текущих счетчиков байтов                    \e[32m -db --display-bytes \e[0m";}
 M13(){ TPUT 17 3; $e "Отображение текущего количества архивированных записей \e[32m -dc --display-counts \e[0m";}
 M14(){ TPUT 18 3; $e "Отображать точки, пока каждая запись заархивирована      \e[32m -dd --display-dots \e[0m";}
 M15(){ TPUT 19 3; $e "Включать в архив только data-fork файлов                     \e[32m -df --datafork \e[0m";}
 M16(){ TPUT 20 3; $e "Отображать точки прогресса для архива              \e[32m -dg --display-globaldots \e[0m";}
 M17(){ TPUT 21 3; $e "Установите количество обрабатываемого файла        \e[32m -ds size --dot-size size \e[0m";}
 M18(){ TPUT 22 3; $e "Отображение несжатого размера каждой записи             \e[32m -du --display-usize \e[0m";}
 M19(){ TPUT 23 3; $e "Отображение номера тома (диска)                        \e[32m -dv --display-volume \e[0m";}
 M20(){ TPUT 24 3; $e "Не создавайте записи в zip-архиве для каталогов         \e[32m -D --no-dir-entries \e[0m";}
 M21(){ TPUT 25 3; $e "Создайте архив, содержащий новые и измененные файлы\e[32m -DF --difference-archive \e[0m";}
 M22(){ TPUT 26 3; $e "Зашифруйте содержимое zip-архива                               \e[32m -e --encrypt \e[0m";}
 M23(){ TPUT 27 3; $e "Используйте расширенный атрибут .LONGNAME                    \e[32m -E --longnames \e[0m";}
 M24(){ TPUT 28 3; $e "Заменить (освежить) существующую запись в zip-архиве           \e[32m -f --freshen \e[0m";}
 M25(){ TPUT 29 3; $e "Исправьте zip-архив                                   \e[32m -F --fix -FF --fixfix \e[0m";}
 M26(){ TPUT 30 3; $e "Обычно zip пропускает чтение всех обнаруженных FIFO              \e[32m -FI --fifo \e[0m";}
 M27(){ TPUT 31 3; $e "Синхронизируйте содержимое архива с файлами в ОС             \e[32m -FS --filesync \e[0m";}
 M28(){ TPUT 32 3; $e "Расширить (дополнить) указанный zip-архив вместо создания нового  \e[32m -g --grow \e[0m";}
 M29(){ TPUT 33 3; $e "Отображение справочной информации zip                          \e[32m -h -? --help \e[0m";}
 M30(){ TPUT 34 3; $e "Расширенная справка, включающая дополнительные сведения     \e[32m -h2 --more-help \e[0m";}
 M31(){ TPUT 35 3; $e "Включить только указанные файлы                    \e[32m -i files --include files \e[0m";}
 M32(){ TPUT 36 3; $e "Не сканировать файлы изображений                              \e[32m -I --no-image \e[0m";}
 M33(){ TPUT 38 3; $e " Exit                                                                        ";}
LM=33
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 [Системы, использующие EBCDIC] Преобразование файла в формат ASCII
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Настроить самораспаковывающийся исполняемый архив.
 Самораспаковывающийся исполняемый архив создается путем добавления заглушки SFX
 к существующему архиву. Параметр -A указывает zip настроить смещения записей,
 хранящиеся в архиве, чтобы учесть эти данные \"preamble\"
 Примечание: самораспаковывающиеся архивы для Amiga — это особый случай.
 В настоящее время только порт zip для Amiga может настраивать или обновлять их,
 не повреждая их. -J можно использовать для удаления заглушки SFX,
 если необходимо выполнить другие обновления.
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 [WIN32] После того, как архив создан (и проверен, если используется -T,
 что рекомендуется), очистите биты архива обрабатываемых файлов.
 ВНИМАНИЕ: Как только биты очищены, они очищаются. Вы можете использовать
 параметр -sf show files для сохранения списка обработанных файлов на случай,
 если операцию архивирования придется повторить. Также рассмотрите возможность
 использования параметра -MM must match. Не забудьте проверить -DF как,
 возможно, лучший способ сделать инкрементное резервное копирование.
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 [WIN32] Включать только файлы с установленным битом архива.
 Каталоги не сохраняются при использовании -AS, хотя по умолчанию пути записей,
 включая каталоги, сохраняются как обычно и могут использоваться большинством
 распаковщиков для воссоздания каталогов. Архивный бит устанавливается операционной
 системой при изменении файла, и при использовании с параметром -AC параметр -AS
 может обеспечить возможность инкрементного резервного копирования. Однако другие
 приложения могут изменить бит архива, и это может быть ненадежным индикатором
 того, какие файлы были изменены с момента последней операции архивирования.
 Альтернативные способы создания инкрементных резервных копий включают
 использование -t для использования дат файлов, хотя это не позволит поймать старые
 файлы, скопированные в архивируемые каталоги и -DF для создания разностного архива
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 [VM/CMS и MVS] принудительно считывают файл в двоичном виде
 (по умолчанию это текст).
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 [TANDEM] задайте параметры форматирования Edit/Enscribe с n, определенным как
\e[32m bit 0:\e[0m не добавлять разделитель (Edit/Enscribe)
\e[32m bit 1:\e[0m использовать LF вместо CR/LF в качестве разделителя (Edit/Enscribe)
\e[32m bit 2:\e[0m запись заполнения пробела до максимальной длины записи (Enscribe)
\e[32m bit 3:\e[0m Обрезать конечный пробел (Enscribe)
\e[32m bit 8:\e[0m Force 30K (Expand) большое чтение для неструктурированных файлов
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Используйте указанный путь для временного zip-архива. Например:
\e[32m zip -b /tmp stuff *\e[0m
 поместит временный zip-архив в каталог /tmp, скопировав stuff.zip в текущий
 каталог, когда закончите. Этот параметр полезен при обновлении существующего
 архива, когда в файловой системе, содержащей этот старый архив, недостаточно места
 для одновременного хранения старого и нового архивов. В некоторых случаях это
 также может быть полезно при потоковой передаче, чтобы избежать необходимости в
 дескрипторах данных. Обратите внимание, что использование этого параметра может
 потребовать от zip дополнительного времени для копирования файла архива
 в целевую файловую систему.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Добавьте однострочные комментарии для каждого файла.
 Операции с файлами (добавление, обновление) выполняются в первую очередь, а затем
 пользователю предлагается ввести однострочный комментарий для каждого файла.
 Введите комментарий, а затем нажмите Enter
 или просто return, чтобы не комментировать.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 [VMS] Сохранить все дела на VMS. Отрицание этой опции (-C-) в нижнем регистре.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 [VMS] Сохранить случай ODS2 на VMS.
 Отрицание этой опции (-C2-) в нижнем регистре.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 [VMS] Сохранить случай ODS5 на VMS.
 Отрицание этой опции (-C5-) в нижнем регистре.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Удалить (delete) записи из zip-архива. Например:
\e[32m zip -d foo foo/tom/junk foo/harry/\\* \\*.o\\e[0m
 удалит запись foo/tom/junk, все файлы, начинающиеся с foo/harry/, и все файлы,
 заканчивающиеся на .o (в любом пути). Обратите внимание, что расширение пути к
 оболочке было запрещено с помощью обратной косой черты, поэтому zip может видеть
 звездочки, что позволяет zip сопоставлять содержимое zip-архива, а не содержимое
 текущего каталога. (Обратная косая черта не используется на платформах на основе
 MSDOS.) Также можно использовать кавычки, чтобы избежать звездочек, как в
\e[32m zip -d foo foo/tom/junk \"foo/harry/*\" \"*.o\"\e[0m
 Отсутствие экранирования звездочек в системе, где оболочка расширяет
 подстановочные знаки, может привести к тому, что звездочки будут преобразованы в
 список файлов в текущем каталоге, и этот список будет использоваться для удаления
 записей из архива. В MSDOS параметр -d чувствителен к регистру, если он
 соответствует именам в zip-архиве. Для этого требуется, чтобы имена файлов
 вводились в верхнем регистре, если они были заархивированы с помощью PKZIP в
 системе MSDOS. (Мы рассматривали возможность сделать это значение нечувствительным
 к регистру в системах, где пути были нечувствительны к регистру, но возможно, что
 архив получен из системы, где регистр имеет значение, и архив может включать как
 Bar, так и bar как отдельные файлы в архиве.)
 Но см. новое опция -ic игнорировать регистр в архиве.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение текущих счетчиков байтов,
 показывающих заархивированные и оставшиеся байты.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение текущего количества заархивированных записей и записей,
 которые нужно удалить.
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображать точки, пока каждая запись заархивирована (кроме портов, у которых есть
 собственный индикатор выполнения). См. -ds ниже для установки размера точки.
 По умолчанию точка ставится через каждые 10 МБ обрабатываемого входного файла.
 Опция -v также отображает точки, ранее с гораздо большей скоростью, чем эта, но
 теперь -v также по умолчанию равна 10 МБ, и эта скорость также контролируется -ds
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 [MacOS] Включать в архив только data-fork файлов, заархивированных в zip.
 Хорошо подходит для экспорта файлов в иностранные операционные системы.
 Вилки ресурсов будут игнорироваться вообще.
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображать точки прогресса для архива, а не для каждого файла. Команда:
 \e[32m zip -qdgds 10m\e[0m
 отключит большую часть вывода, кроме точек через каждые 10 МБ.
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите количество обрабатываемого входного файла для каждой отображаемой
 точки. См. -dd, чтобы включить отображение точек. Установка этого параметра
 подразумевает -dd.
 Размер указывается в формате nm, где n — число, а m — множитель.
 В настоящее время m может быть k (КБ), m (МБ), g (ГБ) или t (ТБ), поэтому,
 если n равно 100, а m равно k, размер будет 100k, что составляет 100 КБ.
 По умолчанию 10 МБ.
 Параметр -v также отображает точки и теперь по умолчанию также равен 10 МБ.
 Эта скорость также контролируется этой опцией. Размер 0 отключает точки.
 Этот параметр не управляет точками в сообщении «Сканирование файлов»,
 когда zip-сканирует входные файлы. Размер точки для этого фиксирован
 и составляет 2 секунды или фиксированное количество записей,
 в зависимости от того, что больше.
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение несжатого размера каждой записи.
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение номера тома (диска), с которого считывается каждая запись,
 если читается существующий архив и на который записывается.
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Не создавайте записи в zip-архиве для каталогов. Записи каталога создаются
 по умолчанию, чтобы их атрибуты можно было сохранить в zip-архиве.
 Переменную среды ZIPOPT можно использовать для изменения параметров по умолчанию.
 Например под Unix с sh:
\e[32m ZIPOPT=\"-D\"; export ZIPOPT\e[0m
 (Переменная ZIPOPT может использоваться для любой опции, включая -i и -x с
 использованием нового формата опции, описанного ниже, и может включать несколько
 опций.) Параметр -D является сокращением для -x \"*/\", но последний ранее
 не может быть установлен по умолчанию в переменной среды ZIPOPT, поскольку
 содержимое ZIPOPT вставляется в начале командной строки, а список файлов должен
 заканчиваться в конце строки.
 Эта версия zip допускает опции -x и -i в ZIPOPT, если форма:
\e[32m -x file file ... @\e[0m
 используется, где @ (аргумент, который является просто @) завершает список.
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Создайте архив, содержащий все новые и измененные файлы с момента создания
 исходного архива. Чтобы это работало, список входных файлов и текущий каталог
 должны быть такими же, как и во время исходной операции zip.
 Например, если существующий архив был создан с помощью
\e[32m zip -r foofull\e[0m
 из каталога bar, затем команда:\e[32m zip -r foofull\e[0m -DF --out foonew
 также из каталога bar создает архив foonew только с файлами, не входящими в
 foofull, и файлами, в которых размер или время файла не соответствуют файлам
 в foofull. Обратите внимание, что переменная среды часового пояса TZ должна быть
 установлена в соответствии с местным часовым поясом, чтобы эта опция работала
 правильно. Изменение часового пояса с момента создания исходного архива может
 привести к несоответствию времени и включению всех файлов. Возможным подходом к
 резервному копированию каталога может быть создание обычного архива содержимого
 каталога в качестве полной резервной копии, а затем использование
 этого параметра для создания добавочных резервных копий.
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Зашифруйте содержимое zip-архива, используя пароль, который вводится
 на терминале в ответ на приглашение (это не будет отображено; если стандартная
 ошибка не является tty, zip завершится с ошибкой).
 Запрос пароля повторяется, чтобы уберечь пользователя от ошибок ввода.

 Создать zip-архив зашифрованный из файлa:
\e[32m zip -P password -r file.zip file\e[0m

 Создать zip-архив зашифрованный из нескольких файлов:
\e[32m zip --password MY_SECRET secure.zip doc.pdf doc2.pdf doc3.pdf\e[0m
 или
\e[32m zip --password 000 secure.zip *\e[0m

 Создать zip-архив зашифрованный из папки
\e[32m zip -P мойпароль -r mysecretdir.zip mysecretdir\e[0m
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 [OS/2] Используйте расширенный атрибут .LONGNAME
 (если он найден) в качестве имени файла.
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 Заменить (освежить) существующую запись в zip-архиве только в том случае,
 если она была изменена позднее, чем версия, уже находящаяся в zip-архиве;
 в отличие от опции обновления (-u) это не добавит файлы,
 которых еще нет в zip-архиве. Например:\e[32m zip -f foo\e[0m
 Эту команду следует запускать из того же каталога, из которого была запущена
 исходная команда zip, поскольку пути, хранящиеся в zip-архивах, всегда
 относительные. Обратите внимание, что переменная среды часового пояса TZ должна
 быть установлена в соответствии с местным часовым поясом, чтобы параметры -f, -u и
 -o работали правильно. Причины этого довольно тонкие, но они связаны с различиями
 между временем файла в формате Unix (всегда по Гринвичу) и в большинстве других
 операционных систем (всегда по местному времени) и необходимостью их сравнения.
 Типичным значением TZ является «MET-1MEST» (среднеевропейское время с
 автоматической настройкой на «летнее время» или переход на летнее время).
 Формат — TTThhDDD, где TTT — это часовой пояс, такой как MET, hh — это разница
 между GMT и местным временем, например -1 выше, а DDD — это часовой пояс, когда
 действует летнее время. Оставьте DDD, если нет перехода на летнее время.
 Для восточного часового пояса США EST5EDT.
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Исправьте zip-архив.
 Параметр -F можно использовать, если некоторые части архива отсутствуют,
 но при этом требуется достаточно неповрежденный центральный каталог.
 Входной архив сканируется как обычно, но zip игнорирует некоторые проблемы.
 Результирующий архив должен быть действительным, но любые несогласованные
 записи будут исключены.
 При дублировании, как в -FF, архив сканируется с самого начала,
 а zip сканирует специальные подписи, чтобы определить ограничения между
 элементами архива.
 Единственный -F более надежен, если архив не слишком сильно поврежден,
 поэтому сначала попробуйте этот вариант.
 Если архив слишком поврежден или его конец обрезан, необходимо использовать -FF.
 Это изменение по сравнению с zip 2.32, где опция -F может читать усеченный архив.
 Параметр -F теперь более надежно исправляет архивы с незначительными
 повреждениями, а параметр -FF необходим для исправления архивов,
 где раньше могло быть достаточно -F.
 Ни один из вариантов не восстанавливает архивы, которые были неправильно переданы
 в режиме ascii вместо двоичного. После восстановления опция распаковки -t может
 показать, что некоторые файлы имеют неверный CRC.
 Такие файлы невозможно восстановить; вы можете удалить их из архива,
 используя опцию -d zip.
 Обратите внимание, что -FF может иметь проблемы с исправлением архивов,
 содержащих встроенный zip-архив, который был сохранен (без сжатия) в архиве, и в
 зависимости от повреждения, он может найти записи во встроенном архиве, а не в
 самом архиве. Сначала попробуйте -F, так как у него нет этой проблемы.
 Изменился формат команд исправления.
 Например, чтобы исправить поврежденный архив foo.zip:
\e[32m zip -F foo --out foofix\e[0m
 пытается нормально читать записи, копируя хорошие записи в новый архив foofix.zip
 Если это не работает, например, когда архив усекается, или если некоторые записи,
 которые, как вы знаете, в архиве пропущены, попробуйте:
\e[32m zip -FF foo --out foofixfix\e[0m
 и сравните получившийся архив с архивом, созданным с помощью -F.
 Параметр -FF может создать несовместимый архив.
 В зависимости от того, что повреждено, вы можете использовать опцию -F,
 чтобы исправить этот архив.
 Разделенный архив с отсутствующими разделенными файлами можно исправить
 с помощью -F, если у вас есть последний разделенный архив (файл .zip).
 Если этот файл отсутствует, вы должны использовать -FF для исправления архива,
 который предложит вам расщепления, которые у вас есть.
 В настоящее время параметры исправления не могут восстанавливать записи,
 которые имеют неверную контрольную сумму или повреждены иным образом.
";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 [Unix] Обычно zip пропускает чтение всех обнаруженных FIFO (именованных каналов),
 так как zip может зависнуть, если FIFO не загружается.
 Эта опция указывает zip читать содержимое любого найденного FIFO.
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
 Синхронизируйте содержимое архива с файлами в ОС.
 Обычно при обновлении архива добавляются новые файлы и обновляются измененные
 файлы, но файлы, которые больше не существуют в ОС, не удаляются из архива.
 Эта опция включает новый режим, который проверяет записи в архиве на соответствие
 файловой системе. Если время файла и размер файла записи совпадают с файлом ОС,
 запись копируется из старого архива, а не считывается из файловой системы и
 сжимается. Если файл ОС был изменен, запись читается и сжимается как обычно.
 Если запись в архиве не соответствует файлу в ОС, запись удаляется.
 Включение этой опции должно создавать архивы, такие же, как и новые архивы,
 но поскольку существующие записи копируются, а не сжимаются, обновление
 существующего архива с помощью -FS может быть намного быстрее, чем создание
 нового архива. Также рассмотрите возможность использования -u для обновления
 архива. Чтобы эта опция работала, архив должен обновляться из того же каталога,
 в котором он был создан, чтобы относительные пути совпадали. Если из старого
 архива копируется мало файлов, может быть быстрее создать новый архив.
 Обратите внимание, что переменная среды часового пояса TZ должна быть
 установлена в соответствии с местным часовым поясом, чтобы эта опция работала
 правильно. Изменение часового пояса с момента создания исходного архива может
 привести к несоответствию времени и повторному сжатию всех файлов. Эта опция
 удаляет файлы из архива. Если вам нужно сохранить исходный архив, сначала
 сделайте копию архива или используйте параметр --out для вывода обновленного
 архива в новый файл. Несмотря на то, что это может быть медленнее, создание
 нового архива с новым именем архива безопаснее, позволяет избежать
 несоответствия между путями архива и ОС и предпочтительнее.
";ES;fi;;
 28) S=M28;SC;if [[ $cur == enter ]];then R;echo -e "
 Расширить (дополнить) указанный zip-архив вместо создания нового.
 Если эта операция не удалась, zip попытается восстановить архив в исходное
 состояние. Если восстановление не удастся, архив может быть поврежден.
 Этот параметр игнорируется, если архива нет или необходимо обновить
 или удалить хотя бы один член архива.
";ES;fi;;
 29) S=M29;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение справочной информации zip:
\e[32m zip -h\e[0m
\e[32m zip -?\e[0m
\e[32m zip --help\e[0m
 (это также появляется, если zip запускается без аргументов).
";ES;fi;;
 30) S=M30;SC;if [[ $cur == enter ]];then R;echo -e "
 Отображение расширенной справки, включающей дополнительные сведения о формате
 командной строки, сопоставлении шаблонов и других малопонятных параметрах:
\e[32m zip -h2\e[0m
\e[32m zip --more-help\e[0m
";ES;fi;;
 31) S=M31;SC;if [[ $cur == enter ]];then R;echo -e "
 Включить только указанные файлы, например:
\e[32m zip -r foo . -i \\*.c\e[0m
 который будет включать только файлы, оканчивающиеся на .c
 в текущем каталоге и его подкаталогах.
 (Примечание для пользователей PKZIP: эквивалентная команда:
\e[32m pkzip -rP foo *.c\e[0m
 PKZIP не допускает рекурсии в каталогах, отличных от текущего.)
 Обратная косая черта позволяет избежать замены имени файла оболочки, поэтому
 сопоставление имен выполняется zip на всех уровнях каталога.
 [Это для Unix и других систем, где \\ экранирует следующий символ.
 Для других систем, где оболочка не обрабатывает *, не используйте \\,
 а приведенное выше \e[32m zip -r foo . -i *.c\e[0m
 Примеры приведены для Unix, если не указано иное.] Таким образом, чтобы
 включить dir, каталог непосредственно под текущим каталогом, используйте
\e[32m zip -r foo . -i dir/\\*\e[0m или\e[32m zip -r foo . -i \"dir/*\" \e[0m
 для сопоставления таких путей, как dir/a и dir/b/file.c [на портах без
 расширения подстановочных знаков в оболочке, таких как MSDOS и Windows
\e[32m zip -r foo . -i dir/*\e[0m используется.]
 Обратите внимание, что в настоящее время конечный / необходим для каталогов
 (как в\e[32m zip -r foo . -i dir/\e[0m включить каталог dir).
 Форма длинного варианта первого примера:\e[32m zip -r foo . --include \\*.c\e[0m
 и делает то же самое, что и форма короткого варианта.
 Хотя синтаксис команды раньше требовал -i в конце командной строки,
 эта версия фактически разрешает -i (или --include) где угодно.
 Список файлов заканчивается следующим аргументом, начинающимся с -,
 концом командной строки или знаком конца списка @
 (аргументом, который является просто @).
 Таким образом, вышеизложенное можно представить как
\e[32m zip -i \\*.c @ -r foo .\e[0m например.
 Между опцией и первым файлом списка должен быть пробел.
 Только для одного файла вы можете использовать форму с одним значением
\e[32m zip -i\\*.c -r foo .\e[0m
(без пробела между параметром и значением) или
\e[32m zip --include=\\*.c -r foo .\e[0m
 в качестве дополнительных примеров.
 Формы с одним значением не рекомендуются, потому что они могут сбивать с толку,
 и в частности, формат -ifile может вызвать проблемы, если первая буква файла
 объединяется с i, образуя двухбуквенный параметр, начинающийся с i.
 Используйте -sc, чтобы увидеть, как будет анализироваться ваша командная строка.
 Также возможно:\e[32m  zip -r foo  . -i@include.lst\e[0m
 который будет включать только те файлы в текущем каталоге и его подкаталогах,
 которые соответствуют шаблонам в файле include.lst.
 Файлы для -i и -x являются шаблонами, соответствующими внутренним путям архива.
 См. -R для получения дополнительной информации о шаблонах.
";ES;fi;;
 32) S=M32;SC;if [[ $cur == enter ]];then R;echo -e "
 [Acorn RISC OS] Не сканировать файлы изображений. При использовании zip не будет
 рассматривать файлы изображений (например, разделы DOS или архивы Spark при
 загрузке SparkFS) как каталоги, а будет хранить их как отдельные файлы.
 Например, если у вас загружена SparkFS, сжатие архива Spark приведет к созданию
 zip-файла, содержащего каталог (и его содержимое), а использование параметра «I»
 приведет к созданию zip-файла, содержащего архив Spark. Очевидно, что этот второй
 случай также будет получен (без опции «I»), если SparkFS не загружен.
";ES;fi;;
 33) S=M33;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
