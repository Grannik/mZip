#!/bin/bash
source "sZip.sh"
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=38; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
TPUT  1 1;$E "$nb";UNMARK;
TPUT  2 2;$E "\e[36m Options\e[0m                                                      \e[2m Параметры, Опции\e[0m";
TPUT  3 1;$E "$nc";
TPUT 37 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 39 1;$E "$ne";UNMARK;}
  M0(){ TPUT  4 3; $e "Игнорировать регистр при сопоставлении записей архива     \e[32m -ic --ignore-case \e[0m";}
  M1(){ TPUT  5 3; $e "Сохраняйте только имя сохраненного файла                    \e[32m -j --junk-paths \e[0m";}
  M2(){ TPUT  6 3; $e "Запись Fullpath (+ Volname) Будет сохранен полный путь  \e[32m -jj --absolute-path \e[0m";}
  M3(){ TPUT  7 3; $e "Удалите все предшествующие данные                             \e[32m -J --junk-sfx \e[0m";}
  M4(){ TPUT  8 3; $e "Попытаться преобразовать имена и пути в соответствии с MSDOS \e[32m -k --DOS-names \e[0m";}
  M5(){ TPUT  9 3; $e "Преобразуйте символ конца строки Unix LF согласно с MSDOS CR LF\e[32m -l --to-crlf \e[0m";}
  M6(){ TPUT 10 3; $e "Добавить к существующему файлу журнала                     \e[32m -la --log-append \e[0m";}
  M7(){ TPUT 11 3; $e "Откройте файл по указанному пути \e[32m -lf logfilepath --logfile-path logfilepath \e[0m";}
  M8(){ TPUT 12 3; $e "Включите в журнал информационные сообщения                   \e[32m -li --log-info \e[0m";}
  M9(){ TPUT 13 3; $e "Переведите конечный CR LF MSDOS в Unix LF                   \e[32m -ll --from-crlf \e[0m";}
 M10(){ TPUT 14 3; $e "Показать ZIP-лицензию                                          \e[32m -L --license \e[0m";}
 M11(){ TPUT 15 3; $e "Переместите указанные файлы в zip-архив                           \e[32m -m --move \e[0m";}
 M12(){ TPUT 16 3; $e "Все входные шаблоны должны соответствовать одному файлу    \e[32m -MM --must-match \e[0m";}
 M13(){ TPUT 17 3; $e "Не пытайтесь сжимать файлы с суффиксами     \e[32m -n suffixes --suffixes suffixes \e[0m";}
 M14(){ TPUT 18 3; $e "Не выполнять внутреннюю обработку подстановочных знаков       \e[32m -nw --no-wild \e[0m";}
 M15(){ TPUT 19 3; $e "Сохраняйте примечания к файлам Amiga или MacOS                   \e[32m -N --notes \e[0m";}
 M16(){ TPUT 20 3; $e "Установите время «последнего изменения» zip-архива         \e[32m -o --latest-time \e[0m";}
 M17(){ TPUT 21 3; $e "Выведите архив в выходной файл     \e[32m -O output-file --output-file output-file \e[0m";}
 M18(){ TPUT 22 3; $e "Включите относительные пути к файлам как часть имен файлов       \e[32m -p --paths \e[0m";}
 M19(){ TPUT 23 3; $e "Используйте пароль для шифрования zip-файла \e[32m -P password --password password \e[0m";}
 M20(){ TPUT 24 3; $e "Бесшумный режим                                                  \e[32m -q --quiet \e[0m";}
 M21(){ TPUT 25 3; $e "Хранит информацию о файле в заголовке файла с n              \e[32m -Qn --Q-flag n \e[0m";}
 M22(){ TPUT 26 3; $e "Рекурсивно перемещайтесь по структуре каталогов          \e[32m -r --recurse-paths \e[0m";}
 M23(){ TPUT 27 3; $e "Рекурсивно перемещаться по структуре каталогов        \e[32m -R --recurse-patterns \e[0m";}
 M24(){ TPUT 28 3; $e "До zip 3.0 сопоставление списков регулярных выражений           \e[32m -RE --regex \e[0m";}
 M25(){ TPUT 29 3; $e "Включите создание разделенного архива   \e[32m -s splitsize --split-size splitsize \e[0m";}
 M26(){ TPUT 30 3; $e "При разделении звоните в колокольчик                       \e[32m -sb --split-bell \e[0m";}
 M27(){ TPUT 31 3; $e "Покажите терминал, запускающую zip как обработанную      \e[32m -sc --show-command \e[0m";}
 M28(){ TPUT 32 3; $e "Покажите файлы, над которыми будут работать, затем выйдите \e[32m -sf --show-files \e[0m";}
 M29(){ TPUT 33 3; $e "Показать все доступные параметры, поддерживаемые zip     \e[32m -so --show-options \e[0m";}
 M30(){ TPUT 34 3; $e "С помощью -s, включите режим разделения паузы             \e[32m -sp --split-pause \e[0m";}
 M31(){ TPUT 35 3; $e "Как -sf, но также показывать версию пути в Unicode       \e[32m -su --show-unicode \e[0m";}
 M32(){ TPUT 36 3; $e "То же, что -sf, но показывать версию в Юникоде      \e[32m -sU --show-just-unicode \e[0m";}
 M33(){ TPUT 38 3; $e "Exit                                                                         ";}
LM=33
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 [VMS, WIN32] Игнорировать регистр при сопоставлении записей архива.
 Этот параметр доступен только в системах, где регистр файлов игнорируется.
 В системах с нечувствительными к регистру файловыми системами регистр обычно
 игнорируется при сопоставлении файлов в файловой системе, но не игнорируется для
 -f (освежение), -d (удаление), -U (копирование) и подобных режимов при
 сопоставлении с архивом. записей (в настоящее время -f игнорирует регистр в VMS),
 потому что архивные записи могут быть из систем, где регистр имеет значение,
 а имена, за исключением регистра, могут существовать в архиве.
 Параметр -ic делает все совпадения нечувствительными к регистру.
 Это может привести к тому, что несколько записей архива будут соответствовать
 шаблону командной строки.
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Сохраняйте только имя сохраненного файла
 (сбросьте путь) и не сохраняйте имена каталогов.
 По умолчанию zip сохраняет полный путь (относительно текущего каталога).
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 [MacOS] запись Fullpath (+ Volname). Будет сохранен полный путь, включая том.
 По умолчанию будет сохранен относительный путь.
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Удалите все предшествующие данные (например, SFX-заглушку) из архива.
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Попытаться преобразовать имена и пути в соответствии с MSDOS,
 сохранить только атрибут MSDOS (только атрибут записи пользователя из Unix)
 и пометить запись как сделанную в MSDOS (даже если это не так)
 для совместимости с PKUNZIP под MSDOS,
 которая не может обрабатывать определенные имена, например, с двумя точками.
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Преобразуйте символ конца строки Unix LF в соглашение MSDOS CR LF.
 Этот параметр не следует использовать для двоичных файлов. Эту опцию можно
 использовать в Unix, если zip-файл предназначен для PKUNZIP под MSDOS.
 Если входные файлы уже содержат CR LF, эта опция добавляет дополнительный CR.
 Это делается для того, чтобы unzip -a в Unix вернула точную копию исходного файла,
 чтобы отменить действие zip -l. См. -ll, как обрабатываются двоичные файлы.
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Добавить к существующему файлу журнала. По умолчанию перезаписывается.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Откройте файл журнала по указанному пути.
 По умолчанию любой существующий файл в этом месте перезаписывается,
 но параметр -la приведет к открытию существующего файла
 и добавлению новой информации журнала к любой существующей информации.
 В журнал записываются только предупреждения и ошибки,
 если не указан параметр -li,
 тогда все информационные сообщения также записываются в журнал.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Включите в журнал информационные сообщения, например, об именах архивируемых
 файлов. По умолчанию включаются только командная строка, любые предупреждения
 и ошибки, а также окончательный статус.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Переведите конечный CR LF MSDOS в Unix LF.
 Этот параметр не следует использовать для двоичных файлов. Эту опцию можно
 использовать в MSDOS, если zip-файл предназначен для распаковки в Unix.
 Если файл преобразован, а позже определяется как двоичный, выдается предупреждение
 и файл вероятно поврежден. В этом выпуске, если -ll обнаруживает двоичный файл в
 первом буфере, считанном из файла, zip теперь выдает предупреждение и пропускает
 преобразование конца строки в файле. Эта проверка, по-видимому, перехватывает все
 проверенные двоичные файлы, но исходная проверка остается, и если позже будет
 определено, что преобразованный файл является двоичным, предупреждение все равно
 выдается. В настоящее время используется новый алгоритм для обнаружения двоичных
 файлов, который должен позволять преобразование конца строки текстовых файлов
 в UTF-8 и аналогичные кодировки.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 Показать ZIP-лицензию:
\e[32m zip -L\e[0m или\e[32m zip --license\e[0m
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Переместите указанные файлы в zip-архив; на самом деле это удаляет целевые
 каталоги/файлы после создания указанного zip-архива.
 Если каталог становится пустым после удаления файлов, каталог также удаляется.
 Никакие удаления не выполняются до тех пор, пока zip не создаст архив без ошибок.
 Это полезно для экономии места на диске, но потенциально опасно, поэтому
 рекомендуется использовать его в сочетании с -T
 для проверки архива перед удалением всех входных файлов.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Все входные шаблоны должны соответствовать хотя бы одному файлу,
 и все найденные входные файлы должны быть доступны для чтения.
 Обычно, когда входной шаблон не соответствует файлу, выдается предупреждение
 «имя не соответствует», а когда входной файл был найден, но позже отсутствует
 или не читается, выдается предупреждение об отсутствии или нечитаемости.
 В любом случае zip продолжает создавать архив, при этом отсутствующие
 или нечитаемые новые файлы пропускаются, а файлы, уже находящиеся в архиве,
 остаются без изменений.
 После создания архива, если какие-либо файлы не читаются, zip возвращает
 код ошибки OPEN (18 в большинстве систем)
 вместо обычного успешного завершения (0 в большинстве систем).
 Если установлено -MM, zip завершает работу, как только входной шаблон не
 соответствует (всякий раз, когда выдается предупреждение «имя не соответствует»)
 или когда входной файл не читается. В любом случае zip завершает работу с ошибкой
 OPEN, и архив не создается. Этот параметр полезен, когда известный список файлов
 должен быть заархивирован, поэтому любые отсутствующие или нечитаемые файлы
 приведут к ошибке. Это менее полезно при использовании с подстановочными знаками,
 но zip все равно завершится с ошибкой, если какой-либо входной шаблон не
 соответствует хотя бы одному файлу и если какие-либо совпавшие файлы не читаются.
 Если вы все равно хотите создать архив и вам нужно знать только,
 были ли пропущены файлы, не используйте -MM и просто проверьте код возврата.
 Также может быть полезен параметр -lf.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Не пытайтесь сжимать файлы с указанными суффиксами.
 Такие файлы просто сохраняются (сжатие 0%) в выходном zip-файле,
 так что zip не тратит время на их сжатие.
 Суффиксы разделяются двоеточием или точкой с запятой. Например:
\e[32m zip -rn .Z:.zip:.tiff:.gif:.snd foo foo\e[0m
 скопирует все из foo в foo.zip, но сохранит любые файлы, которые заканчиваются на
\e[32m .Z, .zip, .tiff, .gif или .snd\e[0m
 не пытаясь их сжать (файлы изображений и звуков часто имеют свои собственные
 специализированные методы сжатия).
 По умолчанию zip не сжимает файлы с расширениями из списка
\e[32m .Z:.zip:.zoo:.arc:.lzh:.arj\e[0m
 Такие файлы сохраняются непосредственно в выходном архиве.
 Переменную среды ZIPOPT можно использовать для изменения параметров по умолчанию.
 Например под Unix с csh:
\e[32m setenv ZIPOPT \"-n .gif:.zip\"\e[0m
 Чтобы попытаться сжать все файлы, используйте:
 \e[32m zip -n : foo\e[0m Параметр максимального сжатия -9
 также пытается сжать все файлы независимо от расширения.
 В системах ОС Acorn RISC суффиксы на самом деле являются типами файлов
 (формат из 3 шестнадцатеричных цифр).
 По умолчанию zip не сжимает файлы с типами файлов из списка
 DDC:D96:68E (т. е. архивы, файлы CFS и файлы PackDir).
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Не выполнять внутреннюю обработку подстановочных знаков
 (обработка подстановочных знаков выполняется оболочкой,
 если только аргументы не экранированы). Полезно,
 если считывается список путей и не требуется замена подстановочных знаков.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 [Amiga, MacOS] Сохраняйте примечания к файлам Amiga или MacOS как комментарии
 к zip-файлам. Их можно восстановить, используя опцию -N для распаковки.
 Если также используется -c, комментарии запрашиваются только для тех файлов,
 которые не имеют примечаний к файлам.
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите время «последнего изменения» zip-архива на самое последнее
 (самое старое) время «последнего изменения», найденное среди записей в zip-архиве.
 При желании его можно использовать без каких-либо других операций. Например:
\e[32m zip -o foo\e[0m изменит время последнего изменения foo.zip
 на самое последнее время записей в foo.zip.
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Обработайте архивные изменения как обычно, но вместо обновления существующего
 архива выведите новый архив в выходной файл. Полезно для обновления архива без
 изменения существующего архива, и входной архив должен быть файлом, отличным от
 выходного архива. Эту опцию можно использовать для создания обновленных
 разделенных архивов. Его также можно использовать с -U для копирования записей
 из существующего архива в новый архив.
 См. раздел ПРИМЕРЫ ниже. Другое использование — преобразование zip-файлов из
 одного размера разделения в другой. Например, чтобы преобразовать архив
 с разделами CD по 700 МБ в архив с разделами DVD по 2 ГБ, можно использовать:
\e[32m zip -s 2g cd-split.zip --out dvd-split.zip\e[0m
 который использует режим копирования. См. -U ниже. Также:
\e[32m zip -s 0 split.zip --out unsplit.zip\e[0m
 преобразует разделенный архив в однофайловый архив.
 Режим копирования преобразует записи потока (с использованием дескрипторов
 данных и которые должны быть совместимы с большинством распаковок)
 в обычные записи (которые должны быть совместимы со всеми распаковками),
 за исключением случаев, когда использовалось стандартное шифрование.
 Для архивов с зашифрованными записями zipcloak расшифрует записи
 и преобразует их в обычные записи.
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Включите относительные пути к файлам как часть имен файлов, хранящихся в архиве.
 Это значение по умолчанию.
 Параметр -j отбрасывает пути и просто сохраняет имена файлов.
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Используйте пароль для шифрования записей zip-файла (если есть). ЭТО НЕБЕЗОПАСНО!
 Многие многопользовательские операционные системы позволяют любому пользователю
 видеть текущую командную строку любого другого пользователя; даже в автономных
 системах всегда существует угроза подглядывания через плечо.
 Хранение открытого текста пароля как части командной строки в автоматизированном
 сценарии еще хуже. По возможности используйте интерактивную подсказку без эха
 для ввода паролей. (А там, где безопасность действительно важна, используйте
 надежное шифрование, такое как Pretty Good Privacy, вместо относительно слабого
 стандартного шифрования, предоставляемого утилитами zipfile.)
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Бесшумный режим; исключить информационные сообщения и подсказки о комментариях.
 (Полезно, например, в сценариях оболочки и фоновых задачах).
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 [QDOS] хранит информацию о файле в заголовке файла с n, определенным как
\e[32m bit 0:\e[0m не добавлять заголовки для любого файла
\e[32m bit 1:\e[0m добавить заголовки для всех файлов
\e[32m bit 2:\e[0m не ждать интерактивного нажатия клавиши при выходе
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Рекурсивно перемещайтесь по структуре каталогов, например:
\e[32m zip -r foo.zip foo\e[0m
 или более кратко
\e[32m zip -r foo foo\e[0m
 В этом случае все файлы и каталоги в foo сохраняются в zip-архиве с именем foo.zip
 включая файлы с именами, начинающимися с \".\", поскольку рекурсия не использует
 механизм подстановки имен файлов оболочки.
 Если вы хотите включить только определенное подмножество файлов в каталоге foo
 и его подкаталогах, используйте параметр -i, чтобы указать шаблон файлов, которые
 необходимо включить. Вы не должны использовать -r с именем \".*\", так как это
 соответствует \"..\", что попытается заархивировать родительский каталог
 (вероятно, не то, что предполагалось).
 Допускается несколько исходных каталогов, как в
\e[32m zip -r foo foo1 foo2\e[0m
 который сначала заархивирует foo1, а затем foo2, спускаясь по каждому каталогу.
 Обратите внимание, что хотя подстановочные знаки для -r обычно разрешаются при
 рекурсивном переходе вниз по каталогам в файловой системе, любые подстановочные
 знаки -R, -x и -i применяются к внутренним путям к архивам после сканирования
 каталогов. Чтобы подстановочные знаки применялись к файлам в подкаталогах при
 рекурсии в Unix и подобных системах, где оболочка выполняет подстановку
 подстановочных знаков, либо экранируйте все подстановочные знаки, либо поместите
 все аргументы с подстановочными знаками в кавычки.
 Это позволяет zip видеть подстановочные знаки
 и сопоставлять файлы в подкаталогах, используя их при рекурсии.
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 Рекурсивно перемещаться по структуре каталогов, начиная с текущего каталога;
 например:\e[32m  zip -R foo \"*.c\"\e[0m
 В этом случае все файлы, соответствующие *.c в дереве, начиная с текущего каталога
 сохраняются в zip-архиве с именем foo.zip. Обратите внимание, что *.c будет
 соответствовать файлу.c, a/file.c и a/b/.c. В качестве отдельных аргументов может
 быть указано более одного шаблона.
 Примечание для пользователей PKZIP: эквивалентная команда\e[32m pkzip -rP foo *.c\e[0m
 Шаблоны представляют собой относительные пути к файлам, как они появляются в
 архиве или будут после архивирования, и могут содержать необязательные
 подстановочные знаки. Например, если текущий каталог называется foo,
 в нем находятся каталоги foo1 и foo2, а в foo1 находится файл bar.c,
\e[32m zip -R foo/*\e[0m
 будут zip up foo, foo/foo1, foo/foo1/bar.c, и foo/foo2
\e[32m zip -R */bar.c\e[0m
 будут zip up foo/foo1/bar.c
 См. примечание для -r об экранировании подстановочных знаков.
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 [WIN32] До zip 3.0 сопоставление списков регулярных выражений было включено
 по умолчанию на платформах Windows. Из-за путаницы, возникающей из-за
 необходимости экранировать \"[\" и \"]\" в именах, теперь это отключено по
 умолчанию для Windows, поэтому \"[\" и \"]\" — это обычные символы в именах.
 Эта опция снова включает сопоставление []
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Создание сплит Zip файла
 Представьте, что вы хотите хранить Zip-архив в службе размещения файлов, у
 которой ограничение размера загрузки файла составляет 1 ГБ, а ваш Zip-архив
 составляет 5 ГБ.
 Вы можете создать новый разделенный Zip-файл, используя -s опцию с указанным
 размером. Множитель может быть k (килобайт), m (мегабайт), g (гигабайт) или t
 (терабайт).
\e[32m zip -s 1g -r archivename.zip directory_name\e[0m
 Приведенная выше команда будет продолжать создавать новые архивы в наборе после
 достижения указанного предела размера.

 Включите создание разделенного архива и установите размер разделения.
 Разделенный архив — это архив, который можно разделить на несколько файлов.
 При создании архива, если размер архива достигает указанного размера разделения,
 это разделение закрывается и открывается следующее разделение. Как правило,
 все разбивается, но последним будет размер разделения, а последним будет то,
 что осталось. Если весь архив меньше размера разделения, создается однофайловый
 архив. Разделенные архивы хранятся в пронумерованных файлах.
 Например, если выходной архив называется архивом и требуется три разделения,
 результирующий архив будет состоять из трех файлов:
 archive.z01, archive.z02, and archive.zip
 Не изменяйте нумерацию этих файлов, иначе архив будет нечитаем, поскольку они
 используются для определения порядка чтения разделов. Размер разделения
 — это число, за которым может следовать множитель. В настоящее время число
 должно быть целым числом. В настоящее время множитель может быть одним из
 k (килобайты), m (мегабайты), g (гигабайты) или t (терабайты).
 Поскольку 64 КБ — это минимальный размер разделения, числа без множителей
 по умолчанию равны мегабайтам. Например, чтобы создать раздельный архив
 с именем foo с содержимым каталога bar с разделами по 670 МБ, который
 может быть полезен для записи на компакт-диски, выполните команду:
\e[32m zip -s 670m -r foo bar\e[0m может быть использован.
 В настоящее время старые разбиения разделенного архива не исключаются из нового
 архива, но их можно специально исключить. Если возможно, держите входные
 и выходные архивы вне пути архивирования при создании разделенных архивов.
 Использование -s без -sp, как указано выше, создает все разбиения, в которые
 записывается foo, в данном случае текущий каталог. Этот режим разделения
 обновляет разделения по мере создания архива, требуя, чтобы все разделения
 оставались доступными для записи, но создает разделенные архивы, доступные для
 чтения любой распаковкой, поддерживающей разделенные архивы.
 См. -sp ниже, чтобы включить режим разделенной паузы, который позволяет
 записывать фрагменты непосредственно на съемный носитель.
 Параметр -sv можно использовать для включения подробного разделения
 и предоставления сведений о том, как выполняется разделение.
 Параметр -sb можно использовать для звонка, когда zip делает паузу
 для следующего пункта назначения разделения. Разделенные архивы не могут быть
 обновлены, но см. параметр -O (--out), чтобы узнать, как можно обновить
 разделенный архив при его копировании в новый архив. Разделенный архив также
 можно преобразовать в однофайловый архив,
 используя размер разделения 0 или отрицая параметр -s:
\e[32m zip -s 0 split.zip --out single.zip\e[0m
 Также см. -U (--copy) для получения дополнительной информации
 об использовании режима копирования.
";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 При разделении и использовании режима разделенной паузы звоните в колокольчик,
 когда почтовый индекс делает паузу для каждого места назначения разделения.
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
 Покажите командную строку, запускающую zip как обработанную, и выйдите.
 Новый синтаксический анализатор команд переставляет аргументы, помещая все
 параметры и любые связанные с ними значения перед любыми аргументами,
 не являющимися параметрами. Это позволяет параметру появляться в любом месте
 командной строки, если любые значения, связанные с параметром, соответствуют ему.
 Эта опция отображает командную строку так, как ее видит zip, включая любые
 аргументы из среды, например из переменной ZIPOPT. Там, где это разрешено,
 параметры, расположенные позже в командной строке, могут иметь приоритет
 перед параметрами, указанными ранее в командной строке.
";ES;fi;;
 28) S=M28;SC;if [[ $cur == enter ]];then R;echo -e "
 Покажите файлы, над которыми будут работать, затем выйдите.
 Например, при создании нового архива будут перечислены файлы, которые будут
 добавлены. Если опция отключена, -sf-, вывод только в открытый файл журнала.
 Отображение на экране не рекомендуется для больших списков.
";ES;fi;;
 29) S=M29;SC;if [[ $cur == enter ]];then R;echo -e "
 Показать все доступные параметры, поддерживаемые zip, скомпилированные в текущей
 системе. Поскольку эта команда считывает таблицу параметров, она должна включать
 все параметры. Каждая строка включает краткую опцию (если определена),
 длинную опцию (если определена), формат любого значения, которое идет с опцией,
 если опция может быть инвертирована, и небольшое описание. Формат значения может
 быть без значения, обязательным значением, необязательным значением,
 односимвольным значением, числовым значением или списком значений.
 Вывод этой опции не предназначен для того, чтобы показать, как использовать
 какую-либо опцию, а только для того, чтобы показать, какие опции доступны.
";ES;fi;;
 30) S=M30;SC;if [[ $cur == enter ]];then R;echo -e "
 Если разделение включено с помощью -s, включите режим разделения паузы.
 Это создает разделенные архивы, как это делает -s, но используется потоковая
 запись, поэтому каждое разделение может быть закрыто, как только оно будет
 записано, и zip будет делать паузу между каждым разделением, чтобы разрешить
 изменение места назначения разделения или носителя. Хотя этот режим разделения
 позволяет записывать фрагменты непосредственно на съемный носитель, он использует
 формат потокового архива, который может быть нечитаем некоторыми распаковщиками.
 Прежде чем полагаться на сплиты, созданные с помощью -sp, протестируйте
 сплит-архив с помощью распаковки, которую вы будете использовать.
 Чтобы преобразовать разделенный потоком архив (созданный с помощью -sp)
 в стандартный архив, используйте параметр --out.
";ES;fi;;
 31) S=M31;SC;if [[ $cur == enter ]];then R;echo -e "
 Как -sf, но также показывать версию пути в Unicode, если она существует.
";ES;fi;;
 32) S=M32;SC;if [[ $cur == enter ]];then R;echo -e "
 То же, что и -sf, но показывать только версию пути в Юникоде,
 если она существует, в противном случае показывать стандартную версию пути.
";ES;fi;;
 33) S=M33;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
